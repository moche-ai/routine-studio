from fastapi import APIRouter, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from enum import Enum
import jwt
import bcrypt
import json
import os
from datetime import datetime, timedelta
from typing import Optional
import uuid

router = APIRouter(prefix="/api/auth", tags=["auth"])
security = HTTPBearer()

# 설정
SECRET_KEY = os.getenv("JWT_SECRET", "routine-studio-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 24 * 7  # 7일

# 사용자 데이터 파일
USERS_FILE = "/data/routine/routine-studio-v2/data/users.json"

# 데이터 디렉토리 생성
os.makedirs(os.path.dirname(USERS_FILE), exist_ok=True)


# Role Enum
class Role(str, Enum):
    ADMIN = "ADMIN"      # 모든 권한
    MANAGER = "MANAGER"  # 수정 권한
    VIEWER = "VIEWER"    # 조회만


# Pydantic 모델
class UserRegister(BaseModel):
    username: str = Field(..., min_length=3, max_length=15, description="아이디 (3-15자)")
    password: str = Field(..., min_length=3, max_length=15, description="비밀번호 (3-15자)")
    name: Optional[str] = None


class UserLogin(BaseModel):
    username: str = Field(..., min_length=3, max_length=15)
    password: str = Field(..., min_length=3, max_length=15)


class UserResponse(BaseModel):
    id: str
    username: str
    name: Optional[str]
    role: Role
    is_approved: bool
    created_at: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: UserResponse


# 헬퍼 함수
def load_users() -> dict:
    if os.path.exists(USERS_FILE):
        with open(USERS_FILE, "r") as f:
            return json.load(f)
    return {}


def save_users(users: dict):
    with open(USERS_FILE, "w") as f:
        json.dump(users, f, indent=2, ensure_ascii=False)


def hash_password(password: str) -> str:
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()


def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode(), hashed.encode())


def create_token(user_id: str, username: str, role: Role) -> str:
    expire = datetime.utcnow() + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)
    payload = {
        "sub": user_id,
        "username": username,
        "role": role.value,
        "exp": expire
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def verify_token(token: str) -> dict:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
    payload = verify_token(credentials.credentials)
    users = load_users()
    user = users.get(payload["sub"])
    if not user:
        raise HTTPException(status_code=401, detail="User not found")
    if not user.get("is_approved", False):
        raise HTTPException(status_code=403, detail="Account not approved")
    return user


def require_role(*allowed_roles: Role):
    """역할 기반 접근 제어 의존성"""
    async def role_checker(user: dict = Depends(get_current_user)):
        user_role = Role(user.get("role", "VIEWER"))
        if user_role not in allowed_roles:
            raise HTTPException(
                status_code=403, 
                detail=f"Required role: {[r.value for r in allowed_roles]}"
            )
        return user
    return role_checker


# 라우트
@router.post("/register", response_model=TokenResponse)
async def register(data: UserRegister):
    users = load_users()
    
    # 아이디 중복 체크
    for user in users.values():
        if user["username"] == data.username:
            raise HTTPException(status_code=400, detail="이미 사용 중인 아이디입니다")
    
    # 사용자 생성 (승인 대기 상태)
    user_id = str(uuid.uuid4())
    user = {
        "id": user_id,
        "username": data.username,
        "password": hash_password(data.password),
        "name": data.name or data.username,
        "role": Role.VIEWER.value,  # 기본 역할은 VIEWER
        "is_approved": False,  # 승인 대기
        "created_at": datetime.utcnow().isoformat()
    }
    
    users[user_id] = user
    save_users(users)
    
    # 토큰 생성 (승인되지 않았으므로 로그인은 불가)
    token = create_token(user_id, data.username, Role.VIEWER)
    
    return TokenResponse(
        access_token=token,
        user=UserResponse(
            id=user_id,
            username=user["username"],
            name=user["name"],
            role=Role.VIEWER,
            is_approved=False,
            created_at=user["created_at"]
        )
    )


@router.post("/login", response_model=TokenResponse)
async def login(data: UserLogin):
    users = load_users()
    
    # 사용자 찾기
    user = None
    for u in users.values():
        if u["username"] == data.username:
            user = u
            break
    
    if not user:
        raise HTTPException(status_code=401, detail="아이디 또는 비밀번호가 일치하지 않습니다")
    
    # 비밀번호 확인
    if not verify_password(data.password, user["password"]):
        raise HTTPException(status_code=401, detail="아이디 또는 비밀번호가 일치하지 않습니다")
    
    # 승인 여부 확인
    if not user.get("is_approved", False):
        raise HTTPException(status_code=403, detail="관리자 승인 대기 중입니다. 승인 후 로그인할 수 있습니다.")
    
    # 토큰 생성
    role = Role(user.get("role", "VIEWER"))
    token = create_token(user["id"], user["username"], role)
    
    return TokenResponse(
        access_token=token,
        user=UserResponse(
            id=user["id"],
            username=user["username"],
            name=user["name"],
            role=role,
            is_approved=user.get("is_approved", False),
            created_at=user["created_at"]
        )
    )


@router.get("/me", response_model=UserResponse)
async def get_me(user: dict = Depends(get_current_user)):
    return UserResponse(
        id=user["id"],
        username=user["username"],
        name=user["name"],
        role=Role(user.get("role", "VIEWER")),
        is_approved=user.get("is_approved", False),
        created_at=user["created_at"]
    )


@router.post("/logout")
async def logout():
    return {"success": True, "message": "Logged out"}
